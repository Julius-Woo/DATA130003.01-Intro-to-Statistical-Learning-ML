---
title: "Statistical Learning HW4"
author: "吴嘉骜 21307130203"
date: "2023-10-27"
output:
  html_document:
    self_contained: yes
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: no
      number_sections: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

```{=html}
<style type="text/css">
h1.title{
  font-size: 38px;
  color: DarkRed;
  text-align: center;
}
h4.author{
  font-size: 18px;
  color: DarkRed;
  text-align: center;
}
h4.date {
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
  text-align: center;
}

</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, cache = TRUE, message = TRUE, fig.align = "center")
library(dplyr)
library(ggplot2)
library(pROC)
```

准备工作

```{r}
# 清除工作环境
cat("\014");rm(list = ls())
# 设置工作目录
setwd("E:/code/DATA130003.01 Intro to Statistical Learning&ML/HW4")
```

## 一、数据读取与预处理

```{r}
# 读入数据
data <- read.csv('Data_Cleaning.csv', header = T, fileEncoding = "utf-8")
abbrs <- read.table("美国大学缩写汇总.txt", col.names = c("full_name", "abbreviation"))
qs <- readLines("QS大学排名前百（美国）.txt")
```

```{r}
# 预处理
## 仅保留录取与拒绝两种结果的数据记录
data$offertype[data$offertype %in% c("Offer", "AD无奖", "AD小奖")] <- "录取"
data$offertype[data$offertype == "Rej"] <- "拒绝" 
data <- data[data$offertype != "WaitingList", ]
data$offertype <- factor(data$offertype, levels = c("拒绝", "录取"))  # 转换为因子型变量，拒绝为0，录取为1

## 修正学校名字
data$college_apply <- gsub("Texas A|M University|Texas A&M University", "Texas A&M University", data$college_apply)
data$college_apply <- gsub("Washington University in St|Louis|Washington University in St. Louis", "Washington University in St. Louis", data$college_apply)

## 将缩写替换为全称

### 将学校名称转换为小写并去除两端的空格
data$college_apply_lower <- tolower(trimws(data$college_apply))
abbrs$abbreviation_lower <- tolower(abbrs$abbreviation)

### 合并数据框，替换缩写为全称
merged_data <- merge(data, abbrs, by.x = "college_apply_lower", by.y = "abbreviation_lower", all.x = TRUE)

### 根据原始行编号重新排序
data <- data[order(data$index_origin),]
merged_data <- merged_data[order(merged_data$index_origin), ]

### 如果缩写没有匹配到全称，就使用原始的学校名称
data$College_apply_new <- ifelse(is.na(merged_data$full_name), merged_data$college_apply, merged_data$full_name)

### 删除不必要的数据以节约空间
rm(merged_data)
data$college_apply_lower <- NULL

## 划分申请学校
data$CollegeRankTop50 <- ifelse(data$College_apply_new %in% qs[1:19], "Top50", "Others")
data$CollegeRankTop50 <- factor(data$CollegeRank, levels = c("Top50", "Others"))

## 对成绩离散化处理
### 将GPA转换为4.0制
data$gpa4 <- (data$gpa / data$gpa_measure) * 4
data$gpa_dis <- cut(data$gpa4, breaks = c(0, 3.4, 3.55, 3.7, Inf), labels = c("<=3.4", "3.4-3.55", "3.55-3.7", ">3.7"))

data$toefl <- as.numeric(data$toefl)
data$toefl_dis <- cut(data$toefl, breaks = c(0, 98, 102, 106, Inf), labels = c("<=98", "98-102", "102-106", ">106"))

### 处理GRE成绩
# data$gre_total <- as.numeric(data$gre_total)
# data$gre_dis <- cut(data$gre_total, breaks = c(0, 300, 320, 330, 340, 1200, 1300, 1400, Inf), labels = c(0.2, "medL", "medH", "high", "low", "medL", "medH", "high"))

# data$stdscore <- data$toefl / 120 * 0.2 + data$gpa4 / 4 * 0.7 + ifelse(data$gre_total <=340, data$gre_total / 340,  data$gre_total / 1606)* 0.1
data$stdscore <- data$toefl / 120 * 0.25 + data$gpa4 / 4 * 0.75

## 将first和sci的负值转换为0
data$first <- ifelse(data$first < 0, 0, data$first)
data$sci <- ifelse(data$sci < 0, 0, data$sci)

## 删除含有缺失值的数据
data <- na.omit(data)
```


## 二、描述性分析

### 1. Top 10热门学校申请人数柱状图
```{r}
# 获得top10学校的数据
top10schools <- data %>%
  group_by(College_apply_new) %>%
  summarize(count = n()) %>%
  arrange(desc(count)) %>%
  head(10)

top10data <- data %>%
  filter(College_apply_new %in% top10schools$College_apply_new)

top10counts <- top10data %>%
  group_by(College_apply_new, offertype) %>% 
  summarize(count = n(), .groups = "drop")

# 绘制柱状图
ggplot(top10counts, aes(x = reorder(College_apply_new, -count), y = count, fill = offertype)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Top 10热门学校申请人数", x = "学校", y = "申请人数") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

由图可见，UC的申请人数最多，这可能是因为UC有很多分校，而我们将其所有分校都归为了同一大类。同时，UC的拒绝人数也是最多的。此外，CMU, USC等大学的热度也很高。其中，USC的录取率看起来是最高的。

### 2. 成绩与录取结果箱线图
```{r}
# toefl
ggplot(data, aes(x = CollegeRankTop50, y = toefl, fill = offertype)) +
  geom_boxplot() +
  labs(title = "Toefl成绩与录取结果箱线图", x = "学校世界排名", y = "Toefl") +
  theme_minimal()
```
如图所示，申请排名前50的学校时，被录取学生的Toefl成绩（中位数）较高；申请其他学校时，学生Toefl成绩差异不明显。且无论是申请排名前50的学校还是其他学校，被录取学生的Toefl成绩波动和被拒绝学生的Toefl成绩波动情况都相差不大，且均有低成绩被录取或拒绝的情况。


## 三、划分数据集，拟合逻辑回归模型

```{r}
# 设置随机种子
set.seed(2023)

# 划分训练集和测试集
test_indices <- sample(1:nrow(data), size =  nrow(data)/5, replace = F)
train_data <- data[-test_indices, ]
test_data <- data[test_indices, ]

# 拟合逻辑回归模型
model0 <- glm(offertype ~ season + type + CollegeRankTop50 + rl + intern + research + paper + first + sci + exchange + gpa_dis + toefl_dis, data = train_data, family = "binomial")
# 使用AIC准则进行变量筛选
model <- step(model0, trace = 0)  # 逐步回归
summary(model)
```
由AIC选择后的模型结果，我们获得了对申请留学结果影响显著的变量。从申请季节来看，以秋季申请为基准组，在控制其他变量不变的情况下，春季申请的同学被录取的可能性大；在控制其他变量不变的情况下，有发表论文、海外交流经历的同学比没有这些经历的同学被录取的可能性大；GPA和Toefl成绩在更高区位的同学被录取的可能性大；从申请学校的世界排名来看，申请前50以外的学校时，被录取的可能性大。


## 四、模型评估和ROC曲线绘制

```{r, message=FALSE}
# 对测试集进行预测
pred <- predict(model, test_data, type="response")
plot.roc(test_data$offertype, col = "dodgerblue", print.auc=TRUE, auc.polygon=TRUE, auc.polygon.col="grey",xlab="特异度", ylab="敏感度", pred, main="预测ROC曲线")
```

AUC值（ROC曲线下的面积）越大，模型的预测效果越好。由上图，AUC值为0.595，说明模型对数据的预测效果好于随机猜测，但仍有很大的改进空间。

## 五、精准率和召回率，混淆矩阵

```{r}
# 生成混淆矩阵
library(caret)
pred_class <- ifelse(pred > 0.6, T,F)
actual_factor <- as.factor(test_data$offertype == "录取")
conf_matrix <- confusionMatrix(as.factor(pred_class), actual_factor)$table
print(conf_matrix)

# 计算精准率和召回率
precision <- conf_matrix[2, 2] / sum(conf_matrix[2, ])
recall <- conf_matrix[2, 2] / sum(conf_matrix[, 2])
print(precision)
print(recall)
```
由混淆矩阵，模型在测试集上的精确率为72.6%，召回率为91.0%。召回率较高，说明真正被录取的样本中，被准确预测为录取的占比较高；而精确率较低，说明被预测为录取的样本中，真正被录取的占比相对低一些。

## 六、成本收益曲线

```{r}
# 设定阈值
thresholds <- seq(0.1, 0.9, by = 0.05)

# 初始化存储结果的向量
capture_rate <- numeric(length(thresholds))
coverage_rate <- numeric(length(thresholds))

# 遍历每个阈值，计算捕获率和覆盖率
for (i in seq_along(thresholds)) {
  threshold <- thresholds[i]
  pred_class <- pred > threshold
  actual_class <- test_data$offertype == "录取"
  
  # 计算混淆矩阵
  TP <- sum(pred_class & actual_class)
  FP <- sum(pred_class & !actual_class)
  FN <- sum(!pred_class & actual_class)
  TN <- sum(!pred_class & !actual_class)
  
  # 计算捕获率和覆盖率
  capture_rate[i] <- TP / (TP + FN)
  coverage_rate[i] <- (TP + FP) / (TP + FP + FN + TN)
}

# 整合到一个数据框中
cost_benefit_df <- data.frame(Threshold = thresholds, Coverage = coverage_rate, Capture = capture_rate)

# 绘制成本收益曲线
library(ggplot2)
ggplot(cost_benefit_df, aes(x = Coverage, y = Capture)) +
  geom_point(aes(color = "模型捕获率")) +
  geom_line(aes(color = "模型捕获率")) +
  geom_abline(aes(slope = 1, intercept = 0, color = "基准捕获率"), linetype = "dashed") +  
  scale_color_manual(name = "图例", values = c("模型捕获率" = "blue", "基准捕获率" = "red")) +
  labs(title = "成本收益曲线", x = "覆盖率", y = "捕获率") +
  theme_minimal()
```

由此可见，当阈值较高，覆盖率较低时，捕获率也较低，模型在严格阈值下的预测效果不好；随着阈值降低，覆盖率提高，捕获率也有所增加，且总是位于基线之上，说明模型的预测效果优于随机猜测。但鉴于它们十分贴合，说明我们很难通过覆盖较少的样本来提高捕获率，模型的精度还不够。

## 七、其他分析

从第三问建立的逻辑回归模型可以看到对模型预测影响较为显著的变量有：申请季节、申请学校是否为Top50、GPA成绩区间、托福成绩区间。拓展信息中的变量因能较好地反映申请人的综合能力，也均予以保留。由模型我们看到GPA对申请结果影响的程度大于托福，但二者标准并不统一。因此我们考虑建立一个归一化后的加权成绩变量：`data$stdscore <- data$toefl / 120 * 0.25 + data$gpa4 / 4 * 0.75`，来替代原来的两个区间变量。对于GRE成绩，一方面存在新旧评价的转换问题，另一方面在尝试后发现其对模型预测影响不大，因此不予考虑。这一步的数据处理已在“数据读取与预处理”中完成。

首先，我们绘制三种成绩的箱线图，考察新设置的加权成绩变量与录取结果的关系。

```{r}
# 绘制TOEFL分数的箱线图
p1 <- ggplot(data, aes(x = offertype, y = toefl)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "TOEFL 分数箱线图")

# 绘制GPA分数的箱线图
p2 <- ggplot(data, aes(x = offertype, y = gpa4)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "GPA 分数箱线图")

# 绘制加权成绩变量的箱线图
p3 <- ggplot(data, aes(x = offertype, y = stdscore)) +
  geom_boxplot(fill = "lightcoral") +
  labs(title = "加权成绩变量箱线图")

gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
```
可见，加权成绩变量相对于是否录取的差异更为明显，且综合了两个成绩的信息，因此我们将其作为模型的一个重要变量。考虑到申请学校所属国家、是否转专业也会对申请结果产生影响，因此也将其纳入模型中。

最终建立的模型及其拟合效果如下：

```{r}
formula <- "offertype ~ season + type + district + CollegeRankTop50 + rl + intern + paper + first + sci + exchange + cross + stdscore"
modelx0 <- glm(formula, data = train_data, family = "binomial")
# 使用AIC准则进行变量筛选
modelx <- step(modelx0, trace = 0)  # 逐步回归
summary(modelx)
```
我们用ROC曲线、混淆矩阵来评估模型的拟合效果。

```{r, message=FALSE}
# 对测试集进行预测
pred <- predict(modelx, test_data, type="response")
plot.roc(test_data$offertype, col = "dodgerblue", print.auc=TRUE, auc.polygon=TRUE, auc.polygon.col="grey",xlab="特异度", ylab="敏感度", pred, main="预测ROC曲线")
```
可见，AUC的值为0.602，比原模型0.595略有提高。

```{r}
# 生成混淆矩阵
library(caret)
pred_class <- ifelse(pred > 0.6, T,F)
actual_factor <- as.factor(test_data$offertype == "录取")
conf_matrix <- confusionMatrix(as.factor(pred_class), actual_factor)$table
print(conf_matrix)

# 计算精准率和召回率
precision <- conf_matrix[2, 2] / sum(conf_matrix[2, ])
recall <- conf_matrix[2, 2] / sum(conf_matrix[, 2])
print(precision)
print(recall)
```
新模型在测试集上的精确率为71.2%，比原模型的72.6%略有下降；召回率为96.8%，比原模型91.0%提高。说明真正被录取的样本中，被准确预测为录取的占比更高了。